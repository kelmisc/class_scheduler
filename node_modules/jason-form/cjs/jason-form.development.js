/**
 * ISC License
 *
 * Copyright (c) 2018, Aleck Greenham
 *
 * Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

function isArray(object) {
  return object !== null && typeof object !== 'undefined' && object.constructor === Array;
}

function isBasicObject(object) {
  return object === Object(object);
}

var fileConstantIsDefined = typeof File === 'function';

function isFile(object) {
  return fileConstantIsDefined && object.constructor === File;
}

function buildFormDataAttributes(key, value) {
  if (isArray(value)) {
    var prefix = key + '[]';

    if (value.length === 0) {
      return [[prefix, null]];
    } else {
      return value.reduce(function (memo, element) {
        return memo.concat(buildFormDataAttributes(prefix, element));
      }, []);
    }
  } else if (value && !isFile(value) && isBasicObject(value)) {

    return Object.keys(value).reduce(function (memo, objectKey) {
      return memo.concat(buildFormDataAttributes(key + '[' + objectKey + ']', value[objectKey]));
    }, []);
  } else {
    return [[key, value]];
  }
}

/**
 * Converts an arbitrarily deep target object into a flat array of key-value
 * tuples with the key converted to a format that is consistent with the
 * naming and formatting conventions of Ruby on Rails.
 *
 * @param {Object} target Object to convert to an array of key-value tuples
 * @returns {FormData} form data compatible with Rails
 */
function formData(target) {

  var attributesList = function () {
    if (target !== null || typeof target !== 'undefined') {

      return Object.keys(target).reduce(function (memo, key) {
        return memo.concat(buildFormDataAttributes(key, target[key]));
      }, []);
    } else {
      return [];
    }
  }();

  var formDataInstance = new FormData();

  attributesList.forEach(function (_ref) {
    var _ref2 = slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    formDataInstance.append(key, value);
  });

  return formDataInstance;
}

module.exports = {
  formData: formData
};
